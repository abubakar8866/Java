ğŸ”¹ Core Multithreading â€“ Industry Questions
1ï¸âƒ£ Why is multithreading required in enterprise applications?
Because enterprise systems must handle many users at the same time.

Real reasons:
Web servers handle 1000s of requests concurrently
Background jobs (email, logging, report generation)
Better CPU utilization
Prevents blocking (DB calls, API calls, file I/O)

Example:
User A â†’ DB query (waiting)
User B â†’ API call (waiting)
User C â†’ File upload
Without multithreading â†’ users wait
With multithreading â†’ system stays responsive âœ…

ğŸ“Œ Enterprise truth:
Multithreading improves throughput, not just speed.

2ï¸âƒ£ Difference between Concurrency vs Parallelism (REAL SYSTEMS)
Aspect	    Concurrency	                Parallelism
Meaning	    Multiple tasks in progress	Multiple tasks executing simultaneously
CPU cores	Can be 1	                Requires multiple cores
Goal	    Responsiveness	            Faster execution
Example	    1 CPU switching threads	    4 cores running 4 threads
ğŸ§  Interview one-liner:
Concurrency is about dealing with many things, parallelism is about doing many things at once.

3ï¸âƒ£ Why is extending Thread discouraged in production code?
âŒ Problems:
Java supports single inheritance
Tightly couples task with thread
Poor design & low reusability
âœ… Better approach:
class MyTask implements Runnable {
    public void run() { }
}
Why industry avoids extends Thread:
âœ” Separation of task & execution
âœ” Works with Executor framework
âœ” Better testability
ğŸ“Œ Enterprise rule:
"Prefer composition over inheritance."

4ï¸âƒ£ When should Runnable be preferred over Callable?
Runnable	                    Callable
No return value	                Returns value
Cannot throw checked exception	Can throw checked exception
Older	                        Used in modern async tasks

Use Runnable when:
Fire-and-forget tasks
Logging, cleanup, background tasks

Use Callable when:
You need a result
Exception handling is required

Callable<Integer> task = () -> 10 + 20;
Future<Integer> result = executor.submit(task);

ğŸ“Œ Production fact:
Callable is preferred for business logic, Runnable for infrastructure tasks.

5ï¸âƒ£ How does JVM schedule threads at OS level?
âš™ï¸ JVM does NOT schedule threads directly

Reality:
JVM creates native OS threads

OS scheduler decides:
Time slicing
CPU allocation
Priority

JVM controls:
Thread priority (hint, not guarantee)
Synchronization rules

ğŸ“Œ Interview answer:
Thread scheduling is OS-dependent and platform-specific.

ğŸ”¹ Thread Lifecycle â€“ System Questions
6ï¸âƒ£ Thread States with REAL Scenarios
State	        Scenario
NEW	Thread      object created
RUNNABLE	    Ready or running
BLOCKED	        Waiting for lock
WAITING	        Waiting indefinitely
TIMED_WAITING	Waiting with timeout
TERMINATED	    Execution finished

7ï¸âƒ£ Why does a thread move to BLOCKED state?
When it tries to enter a synchronized block but another thread owns the lock.
synchronized(obj) {
   // Thread 1 holds lock
}
Thread 2 â†’ BLOCKED until lock is released.
ğŸ“Œ Happens in:
Database connection pools
Shared caches
Singleton initialization

8ï¸âƒ£ WAITING vs TIMED_WAITING (PRODUCTION VIEW)
WAITING	            TIMED_WAITING
Waits indefinitely	Waits for fixed time
wait()	            sleep(ms)
join()	            join(timeout)
Needs notify	    Auto wakeup

ğŸ“Œ Enterprise use:
WAITING â†’ Producerâ€“Consumer
TIMED_WAITING â†’ Polling, retries, backoff logic

9ï¸âƒ£ What happens if a thread is started twice?
Thread t = new Thread();
t.start();
t.start(); // âŒ

ğŸ”¥ Runtime Exception
IllegalThreadStateException

Why?
Thread lifecycle cannot be restarted once terminated.

ğŸ“Œ Interview gold line:
Threads are single-use objects.

ğŸ”Ÿ How does thread lifecycle impact system performance?
Bad lifecycle management causes:
âŒ Thread leaks
âŒ Context switching overhead
âŒ Deadlocks
âŒ CPU starvation

Best practices:
âœ” Use thread pools
âœ” Avoid creating threads manually
âœ” Control lifecycle via Executors

ExecutorService executor = Executors.newFixedThreadPool(10);

ğŸ“Œ Enterprise mantra:
"Manage threads, or threads will manage you."